# Lab 2: Distributed Lock on Reliable Network

## Overview

This lab implements a **distributed lock** on top of a versioned key/value (K/V) store.  
The system assumes a **reliable network** and correct K/V semantics — every successful
`Put()` increments the version number of a key by one, and concurrent `Put()`s on the
same key are serialized by version matching.

The lock is a thin logical layer built on these K/V primitives, using **version parity**
to represent lock state.

---

## Design Summary

### Lock Representation
Each lock corresponds to a key in the K/V store.  
The **version number** associated with that key encodes its state:

- **Even version** → lock is **unlocked**
- **Odd version** → lock is **locked**

The **value** of the key stores a random token generated by the client that acquired it.
This token identifies ownership and prevents accidental unlocks by others.

---

### Key Operations

#### 1. `MakeLock()`
Initializes a lock object for a given key.  
Each lock instance holds:
- A handle to the K/V clerk
- The target key
- A randomly generated value to represent this client's ownership

---

#### 2. `Acquire()`
Attempts to obtain the lock by performing conditional updates in the K/V store:

1. Repeatedly read the key using `Get()`.
2. If the key is missing, or its version is **even**, the client attempts:
    `Put(key, value, even-version)`
The `Put()` succeeds only if the version matches, ensuring atomicity.
3. If the key’s version is **odd**, another client holds the lock.  
The caller waits briefly and retries.
4. On success, the version transitions from even → odd, and the caller owns the lock.

This approach guarantees that **only one client can acquire the lock** at a time.

---

#### 3. `Release()`
Releases the lock safely:

1. Reads the current value and version.
2. Ensures the current client is the owner (`value` matches its token).
3. Performs:
    `Put(key, value, odd-version)`
to move the version from odd → even, unlocking it.
If another client already holds or modified the lock, the `Put()` fails and retries.

---

### Fault Model

The implementation assumes:
- A **reliable network** (no lost or reordered messages)
- Clients do not crash while holding locks

Under these conditions, the lock provides **mutual exclusion** across distributed clients.

If a client crashes while holding a lock, the lock may remain permanently held (no timeout recovery is implemented).

---

### Concurrency Handling

- `Put(key, val, version)` acts as a **compare-and-set (CAS)** at the K/V layer.
- Clients spin with short backoff (`1ms`, optionally exponential) on contention.
- The protocol tolerates concurrent `Acquire()` calls without violating mutual exclusion.

---

### Test execution

```
ba11b73 2025-10-26 Arun Saha (HEAD -> lab2-lock) Lab 2 Lock on Reliable Nw - Mutex not necessary

[src/kvsrv1/lock] $ go test -v -run Reliable
=== RUN   TestOneClientReliable
Test: 1 lock clients (reliable network)...
  ... Passed --  time  2.0s #peers 1 #RPCs   167 #Ops    0
--- PASS: TestOneClientReliable (2.01s)
=== RUN   TestManyClientsReliable
Test: 10 lock clients (reliable network)...
  ... Passed --  time  9.0s #peers 1 #RPCs    10 #Ops    0
--- PASS: TestManyClientsReliable (8.97s)
PASS
ok  	6.5840/kvsrv1/lock	11.001s

```

### Summary

| Operation | Input | Effect | State Change |
|------------|--------|---------|---------------|
| `Acquire()` | lock key | Blocks until lock available | version even → odd |
| `Release()` | lock key | Frees lock if owned | version odd → even |

This design achieves distributed synchronization using only **Get()** and **Put()**
with version checking, without centralized coordination.

---

**Key Properties**
- Simple and stateless clients
- No server-side lock table
- Deterministic ownership via client-generated value
- Safe under concurrent requests
- Efficient and fully decentralized

---